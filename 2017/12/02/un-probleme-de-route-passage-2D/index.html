<!DOCTYPE html>
<html lang="fr">





<head>
	<!-- Required meta tags -->
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="La deuxième étape consiste à passer la simulation à deux dimensions en vue d’implémenter les déviations et intersections. On peut encore séparer cette étape ...">
	<meta name="keywords" content="Programming, Python, and Ingénieur">
	<meta name="author" content="Alexandre Froehlich">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="theme-color" content="#333333">

	<!-- Twitter Tags -->
	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="Un problème de route - Passage en 2D | Alexandre Froehlich">
	<meta name="twitter:description" content="La deuxième étape consiste à passer la simulation à deux dimensions en vue d’implémenter les déviations et intersections. On peut encore séparer cette étape ...">
	<meta name="twitter:image" content="http://localhost:4000/img/boyplusdog.png">
  
	<!-- Open Graph Tags -->
	<meta content="Alexandre Froehlich" property="og:site_name">
	
	  <meta content="Un problème de route - Passage en 2D" property="og:title">
	
  
	
	  <meta content="article" property="og:type">
	
  
	<!--
	  <meta content="<p>La deuxième étape consiste à passer la simulation à deux dimensions en vue d’implémenter les déviations et intersections. On peut encore séparer cette étape en plusieurs sous-étapes : création d’une grille qui va accueillir la route, à la manière d’un plateau contenant des cartes ou des jetons, puis création de la route et finalement adaptation des véhicules au nouveau système de route en 2 dimensions.</p>

" property="og:description">
	-->
  
	
	  <meta content="http://localhost:4000/2017/12/02/un-probleme-de-route-passage-2D/" property="og:url">
	
  
	
	  <meta content="2017-12-02T12:59:14+00:00" property="article:published_time">
	  <meta content="http://localhost:4000/about/" property="article:author">
	
  
	
	  <meta content="http://localhost:4000/public/img/profile.png" property="og:image">
	
  
	
	  
	  <meta content="TIPE" property="article:section">
	  
	
  
	
	  
	
	
	<title>Un problème de route - Passage en 2D | Alexandre Froehlich</title>

	<!-- CSS -->
	<link rel="stylesheet" type="text/css" href="http://localhost:4000/public/css/bootstrap.min.css">
	<link rel="stylesheet" type="text/css" href="http://localhost:4000/public/css/posts.css">
	<link rel="stylesheet" type="text/css" href="http://localhost:4000/public/css/highlighter.css">

	<!-- Icons -->
	<!-- 16x16 -->
	<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
	<!-- 32x32 -->
	<link rel="shortcut icon" href="http://localhost:4000/favicon.png">

	<!-- Javascript -->
	<script src="http://localhost:4000/public/js/p5.js"></script>
	<script src="http://localhost:4000/public/js/bootstrap.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
	type="text/javascript"></script>
	<!-- MathJax config -->
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>

	<!--

		 _   _ _       _     _   _           _     _      
		| \ | (_)     | |   | | | |         (_)   | |     
		|  \| |_  __ _| |__ | |_| |_   _ ___ _  __| | ___ 
		| . ` | |/ _` | '_ \| __| | | | / __| |/ _` |/ _ \
		| |\  | | (_| | | | | |_| | |_| \__ \ | (_| |  __/
		\_| \_/_|\__, |_| |_|\__|_|\__, |___/_|\__,_|\___|
							__/ |             __/ |                 
			   		 |___/             |___/          
		
	-->
</head>

<body>
    <div class="fluid-container wrapper">
        <!-- Sidebar -->
        <nav class="col-md-3 d-none d-md-block sidebar">
    <div class="sidebar-wrapper">
    <img src="http://localhost:4000/public/images/profile.png">
    <div class="row">
        <a href="http://localhost:4000" class="author-name">Alexandre Froehlich</a>
    </div>
    <div class="row">
        <span class="author-bio">Petit développeur indépendant (aka. Nightlyside) dont le rêve est d’être capable de publier
                un projet terminé. Actuellement étudiant en CPGE (PSI* Lycée Kléber)</span>
    </div>
    
    <div class="row">
    <nav class="static-links">
        <ul class="nav-list">
            <li class="nav-item">
                <a href="http://localhost:4000">Accueil</a>
                <span>/</span>
            </li>
            <li class="nav-item">
                <a href="http://localhost:4000/projets.html">Projets</a>
                <span>/</span>
            </li>
            <li class="nav-item">
                <a href="http://localhost:4000/blog.html">Blog</a>
                <span>/</span>
            </li>
            <li class="nav-item">
                <a href="http://localhost:4000/about.html">A propos</a>
            </li>
        </ul>
    </nav>
    </div>

    <div class="social-links"></div>
    </div>
</nav>
        
        <!-- Content -->
        <main class="col-md-8 ml-sm-auto col-lg-9" role="main">
            
            <!-- Cover picture -->
            <div class="row">
                <img class="cover-img" src=
                    
                        "http://localhost:4000/public/images/drone_cover.jpg"
                    
                    alt="Un problème de route - Passage en 2D feature image">
            </div>
            

            <div class="container content">
                <span class="post-category">
                    
                        <a class="link-to-category" href="http://localhost:4000/categories/#TIPE">TIPE</a>
                        
                        <span>/</span>
                        
                    
                        <a class="link-to-category" href="http://localhost:4000/categories/#Code">Code</a>
                        
                    
                </span>
                <h1>Un problème de route - Passage en 2D</h1>
                <span class="post-meta">
                    <span class="post-date">2 DEC 2017</span>
                    •
                    <span class="read-time" title="Temps de lecture estimé">
    
    
        10 minutes
    
</span>
      
                </span>
                <hr>

                <!-- Content -->
                <p>La deuxième étape consiste à passer la simulation à deux dimensions en vue d’implémenter les déviations et intersections. On peut encore séparer cette étape en plusieurs sous-étapes : création d’une grille qui va accueillir la route, à la manière d’un plateau contenant des cartes ou des jetons, puis création de la route et finalement adaptation des véhicules au nouveau système de route en 2 dimensions.</p>

<!--more-->

<h2 id="création-de-la-grille">Création de la grille</h2>

<p>A quoi devra ressembler la grille ? Pour répondre à cette question on pose les conditions de déroulement de la simulation :</p>
<ul>
  <li>la grille devra contenir <strong>W</strong> cases en largeur et <strong>H</strong> cases en hauteur</li>
  <li>la simulation comportera <strong>T</strong> itérations</li>
</ul>

<p>Alors la grille sera représentée par un tableau à 3 dimensions de taille <script type="math/tex">T\times H\times W</script> alors <script type="math/tex">\text{grille}[t]</script> retournera l’état de la grille à l’instant <script type="math/tex">t</script>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">grille_random</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="s">"""
    Crée une grille de façon analogue à grille(w, h, t)
    Et préremplie la grille avec des valeurs aléatoires
    Retourne un tableau de dimension 3 (x, y, t)
    """</span>
    <span class="k">return</span> <span class="p">[[[</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
</code></pre></div></div>

<p>Avec le système actuel d’exportation de tableau qui consiste à attribuer une couleur par case (0 pour blanc, 1 pour vert et 2 pour orange pale) avec chaque couleur associée à un élément de la simulation (respectivement vide, route et véhicule). Le code ci-dessus retournera une grille de la bonne taille. Le remplissage étant aléatoire pour mettre en évidence la structure de la grille, un exemple est le suivant :</p>

<p><img src="http://localhost:4000/public/images/profile.png" alt="Grille aléatoire" height="200px" /></p>

<h2 id="création-de-la-route">Création de la route</h2>

<p>On entame dès à présent une des parties des plus compliquées avec la création de la route. On définit la route comme étant l’ensemble des positions prises par un chemin pour aller d’un point <script type="math/tex">A</script> à un point <script type="math/tex">B</script>.</p>

<p><img src="http://localhost:4000/public/images/profile.png" alt="A vers B" height="200px" /></p>

<p>En prenant les coordonnées de <script type="math/tex">A = (0,0)</script> et <script type="math/tex">B = (2,2)</script> alors le chemin correpondant sera :</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">chemin</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span></code></pre></figure>

<h3 id="algorithme">Algorithme</h3>

<p>Pour créer la route on initialise un tableau contenant les positions de chaque case. On commence par la case du début puis on choisis la prochaine de façon relativement simple, on sera probablement amené qu’à créer des droites ou des angles droits, il n’est donc pas nécessaire de se compliquer la tâche.
Une fois qu’on est arrivée à la dernière case on retourne la liste crée.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">chemin</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">):</span>
  <span class="s">"""
  Permet de créer un chemin entre deux coordonnées pos1, et pos2
  Prends en argument 2 positions (x, y)
  Retourne une liste de positions correspondant au chemin crée
  """</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pos1</span>
  <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pos2</span>
  <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos1</span><span class="p">]</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="n">pos1</span>
  <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">pos2</span><span class="p">:</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">y2</span><span class="p">:</span>
              <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y2</span><span class="p">:</span>
              <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">c</span>
</code></pre></div></div>

<p>A partir de cet algorithme on peut maintenant créer une nouvelle fonction qui prendra une liste de positions par lesquelles le chemin devra passer et qui retournera un tel chemin. Comme on suppose le tracé global simple, on segmente le chemin en traçant la route entre 2 positions à chaque fois.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">chemin_complexe</span><span class="p">(</span><span class="o">*</span><span class="n">positions</span><span class="p">):</span>
    <span class="s">"""
    Permet de créer un chemin complexe, c'est à dire
    un chemin qui passe par n positions
    Retourne le chemin passant par les positions
    """</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cprime</span> <span class="o">=</span> <span class="n">chemin</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="p">[</span><span class="n">cprime</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">c</span>
</code></pre></div></div>

<p><em>A noter qu’écrire <code class="highlighter-rouge">*positions</code> permet de donner autant d’argument à la fonction qu’on le souhaite</em></p>

<p>Par exemple écrire le code ci-dessous :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">route</span> <span class="o">=</span> <span class="n">chemin_complexe</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span>
                        <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>Correspondra à la grille suivante :</p>

<p><img src="http://localhost:4000/public/images/profile.png" alt="A vers B" height="200px" /></p>

<h2 id="faire-avancer-les-voitures">Faire avancer les voitures</h2>

<p>Maintenant qu’on a la grille ainsi que la route qui la parcourt, il est temps de faire avancer les voiture. Pour cela on réutilise le même principe que celui vu dans le post précédent. Cependant un problème nous fait face, en effet comment savoir quelle sera la prochaine case que l’algorithme devra explorer ?</p>

<h3 id="recherche-des-voisins-possibles">Recherche des voisins possibles</h3>

<p>Une solution est de chercher toutes les cases qui juxtapose une position donnée (i.e. qui sont juste à côté de la case), on teste chacune des cases pour savoir si il s’agit bien d’une route. Si oui on l’ajoute à la liste des voisins possible, sinon on passe à la suivante. Une fois qu’on a testé toutes les cases on retourne la liste des cases possibles.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cherche_voisins</span><span class="p">(</span><span class="n">chemin</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="s">"""
    Permet de renvoyer les voisins possibles juxtaposant 
    la position actuelle
    Retourne une liste de positions 
    """</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">voisins</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chemin</span><span class="p">:</span>
            <span class="n">voisins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chemin</span><span class="p">:</span>
            <span class="n">voisins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">voisins</span>
</code></pre></div></div>

<p>Pour choisir la case suivante on liste celle possible, on cherche la case la plus proche de celle à atteindre. Dans le cas où on a une déviation, l’algorithme choisira le chemin le plus court “à vol d’oiseau”. Ce qui à l’air au premier abord de ressembler à la réalité. Enfin.. c’est logique quoi :)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">voisin_plus_proche</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">voisins</span><span class="p">):</span>
    <span class="s">"""
    Retourne le voisin le plus proche d'une position donnée
    Cela permet de décider dans quelle direction aller pour 
    atteindre un point donné
    Retourne une position
    """</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">voisins</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">dmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>
    <span class="n">vproche</span> <span class="o">=</span> <span class="n">voisins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">voisin</span> <span class="ow">in</span> <span class="n">voisins</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">voisin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">voisin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">vproche</span> <span class="o">=</span> <span class="n">voisin</span>
    <span class="k">return</span> <span class="n">vproche</span>
</code></pre></div></div>

<h3 id="nouveau-calcul-de-la-distance">Nouveau calcul de la distance</h3>

<p>L’algorithme du post précédent avait besoin de connaitre la distance de la voiture à celle qui lui précédait pour la phase de décélération. Maintenant on ne peux plus juste calculer la distance cartésienne entre les deux points à cause de la forme de la route. Pour la calculer il suffit de partir de la position de la voiture et de remonter le chemin jusqu’à rencontrer la voiture suivante.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">chemin</span><span class="p">):</span>
    <span class="s">"""
    Essayer de calculer la distance entre 2 cases d'une grille
    en suivant un chemin donné
    Retourne un entier correspondant à la longueur du chemin à faire 
    entre le point pos1 et pos2
    """</span>
    <span class="c1"># On vérifie que les positions appartiennent au chemin
</span>    <span class="k">assert</span> <span class="n">pos1</span> <span class="ow">in</span> <span class="n">route</span> <span class="ow">and</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="n">chemin</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">pos2</span><span class="p">:</span>
        <span class="n">voisins</span> <span class="o">=</span> <span class="n">cherche_voisins</span><span class="p">(</span><span class="n">chemin</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">voisin_plus_proche</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">voisins</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">d</span>
</code></pre></div></div>

<h3 id="déplacer-la-voiture">Déplacer la voiture</h3>

<p>Maintenant qu’on a calculé tout ce qu’il fallait, il ne reste plus qu’à déplacer la voiture le long du chemin à l’aide de tout ce qu’on a définit plus haut. Pour cela on part de la position initiale (<script type="math/tex">pos\_i</script>) puis on parcourt le chemin d’un nombre de cases égal à la vitesse de la voiture (<script type="math/tex">vitesse</script>) si il y avait déjà une voiture, par sécurité on s’arrête, sinon on continue jusqu’à ce qu’on ait terminé.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">avance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pos_i</span><span class="p">,</span> <span class="n">vitesse</span><span class="p">,</span> <span class="n">chemin</span><span class="p">,</span> <span class="n">grille</span><span class="p">):</span>     
    <span class="s">"""
    Calcule la prochaine position d'une voiture sur un chemin
    en fonction de sa vitesse et de la voiture précédente
    Si la voiture devant est à l'arret la voiture actuelle
    s'arrêtera juste avant 
    Retourne une position ainsi que le nombre de case parcourues
    """</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos_i</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">vitesse</span><span class="p">:</span>
        <span class="n">nouvelle_pos</span> <span class="o">=</span> <span class="n">voisin_suivant</span><span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nouvelle_pos</span>
        <span class="k">if</span> <span class="n">grille</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>            
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nouvelle_pos</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="résultat">Résultat</h2>

<p>On réaplique le même procédé que pour la situation linéaire. On prends sur la route du dessus 100 voitures roulant à 130km/h maximum et on calcule la simulation sur 250 itérations. On calcule chaque itération puis on exporte la grille à chaque instant. En assemblant les images dans un GIF animé, on obtient l’animation suivante :</p>

<p><img src="http://localhost:4000/public/images/profile.png" alt="Animation 2D" height="400px" /></p>


            </div>
        </main>
    </div>
</body>
</html>