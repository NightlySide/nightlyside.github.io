<!DOCTYPE html>
<html lang="fr">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

    <!-- Favicon -->
    <link rel="icon" href="https://nightlyside.github.io/new/blog/theme/favicon.ico" />
    <link rel="icon" type="image/png" href="https://nightlyside.github.io/new/blog/theme/favicon.png" />

    <!-- Browser Color -->
 <meta name="author" content="Alexandre Froehlich" />
<meta name="description" content="La deuxième étape consiste à passer la simulation à deux dimensions en vue d&#39;implémenter les déviations et intersections. On peut encore séparer cette étape en plusieurs sous-étapes : création d&#39;une grille qui va accueillir la route, à la manière d&#39;un plateau contenant des cartes ou des jetons, puis création de la …" />
<meta name="keywords" content="concours, TIPE, python" />

    <title>[TIPE] Un problème de route - Passage en 2D (3/4)
 | Alexandre Froehlich</title>

    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/fontawesome.css" />
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/pygments/default.css">
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/blog.css" />

    <!-- Javascript -->
    <script src="https://nightlyside.github.io/new/blog/theme/js/jquery.js"></script>
    <script src="https://nightlyside.github.io/new/blog/theme/js/bootstrap.js"></script>
    <script src="https://nightlyside.github.io/new/blog/theme/js/fontawesome.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
</head>

<body>
    <!--
  _   _ _       _     _   _           _     _      
 | \ | (_) __ _| |__ | |_| |_   _ ___(_) __| | ___ 
 |  \| | |/ _` | '_ \| __| | | | / __| |/ _` |/ _ \
 | |\  | | (_| | | | | |_| | |_| \__ \ | (_| |  __/
 |_| \_|_|\__, |_| |_|\__|_|\__, |___/_|\__,_|\___|
          |___/             |___/                  
-->
    <div class="container-fluid">
        <div class="row">
            <!-- Fixed nav section -->
            <div class="about col-sm-12 col-md-3 col-lg-2">
                <nav class="navbar navbar-fixed-side sticky-top row">
                    <img src="https://nightlyside.github.io/new/blog/images/avatar.png" alt="Alexandre Froehlich" />
                    <h2 class="col-sm-12"><a href="https://nightlyside.github.io/new/blog/">Alexandre Froehlich</a></h2>
                    <p class="col-sm-12">
                        Hobbyist programmer. Petit développeur indépendant (aka.
                        Nightlyside) dont le rêve est d’être capable de publier un projet
                        terminé. Actuellement étudiant à l'ENSTA Bretagne
                    </p>

                    <!-- Navigation -->
                    <ul class="nav-list">
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/">Accueil</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/files/cv.pdf">CV</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/categories">Catégories</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/archives">Archives</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="#">À propos</a>
                        </li>
                    </ul>

                    <!-- Social links -->
                    <ul class="social">
                        <a href="https://github.com/nightlyside">
                            <li><i class="fab fa-github-square"></i></li>
                        </a>
                        <a href="https://www.linkedin.com/in/alexandre-f-1102298a">
                            <li><i class="fab fa-linkedin"></i></li>
                        </a>
                        <a href="https://twitter.com/froalexandre">
                            <li><i class="fab fa-twitter-square"></i></li>
                        </a>
                        <a href="https://reddit.com/u/nightlyside">
                            <li><i class="fab fa-reddit-square"></i></li>
                        </a>
                    </ul>
                </nav>
            </div>
            <!-- Main content -->
            <div class="col-sm-12 col-md-9 col-lg-10 main">
<img class="featured_image" src="https://nightlyside.github.io/new/blog/images/TIPE/random_front.jpg" alt="Image de l'article">
                <div class="container content">
                    <!-- Insert content here -->

<h1 class="title">[TIPE] Un problème de route - Passage en 2D (3/4)</h1>
<p class="sous-titre">
    <span class="date-poste">Posté le sam. 02 décembre 2017 dans <a href="https://nightlyside.github.io/new/blog/category/python.html">python</a></span> <br>
    <span class="temps-lecture">Temps de lecture : 5 minutes</span>
</p>

<hr>
<p>La deuxième étape consiste à passer la simulation à deux dimensions en vue d'implémenter les déviations et intersections. On peut encore séparer cette étape en plusieurs sous-étapes : création d'une grille qui va accueillir la route, à la manière d'un plateau contenant des cartes ou des jetons, puis création de la route et finalement adaptation des véhicules au nouveau système de route en 2 dimensions.</p>
<h2>Création de la grille</h2>
<p>A quoi devra ressembler la grille ? Pour répondre à cette question on pose les conditions de déroulement de la simulation :
* la grille devra contenir <strong>W</strong> cases en largeur et <strong>H</strong> cases en hauteur
* la simulation comportera <strong>T</strong> itérations</p>
<p>Alors la grille sera représentée par un tableau à 3 dimensions de taille $T\times H\times W$ alors $\text{grille}[t]$ retournera l'état de la grille à l'instant $t$.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grille_random</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crée une grille de façon analogue à grille(w, h, t)</span>
<span class="sd">    Et préremplie la grille avec des valeurs aléatoires</span>
<span class="sd">    Retourne un tableau de dimension 3 (x, y, t)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[[[</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
</pre></div>


<p>Avec le système actuel d'exportation de tableau qui consiste à attribuer une couleur par case (0 pour blanc, 1 pour vert et 2 pour orange pale) avec chaque couleur associée à un élément de la simulation (respectivement vide, route et véhicule). Le code ci-dessus retournera une grille de la bonne taille. Le remplissage étant aléatoire pour mettre en évidence la structure de la grille, un exemple est le suivant :</p>
<p><img alt="Grille aléatoire" class="center" height="200px" src="https://nightlyside.github.io/new/blog/images/TIPE/random.jpg" /></p>
<h2>Création de la route</h2>
<p>On entame dès à présent une des parties des plus compliquées avec la création de la route. On définit la route comme étant l'ensemble des positions prises par un chemin pour aller d'un point $A$ à un point $B$.</p>
<p><img alt="A vers B" class="center" height="200px" src="https://nightlyside.github.io/new/blog/images/TIPE/AtoB.jpg" /></p>
<p _="%" endhighlight="endhighlight">En prenant les coordonnées de $A = (0,0)$ et $B = (2,2)$ alors le chemin correpondant sera :
{% highlight python %}
chemin = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]</p>
<h3>Algorithme</h3>
<p>Pour créer la route on initialise un tableau contenant les positions de chaque case. On commence par la case du début puis on choisis la prochaine de façon relativement simple, on sera probablement amené qu'à créer des droites ou des angles droits, il n'est donc pas nécessaire de se compliquer la tâche.
Une fois qu'on est arrivée à la dernière case on retourne la liste crée.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chemin</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Permet de créer un chemin entre deux coordonnées pos1, et pos2</span>
<span class="sd">  Prends en argument 2 positions (x, y)</span>
<span class="sd">  Retourne une liste de positions correspondant au chemin crée</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pos1</span>
  <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pos2</span>
  <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos1</span><span class="p">]</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="n">pos1</span>
  <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">pos2</span><span class="p">:</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">y2</span><span class="p">:</span>
              <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y2</span><span class="p">:</span>
              <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">c</span>
</pre></div>


<p>A partir de cet algorithme on peut maintenant créer une nouvelle fonction qui prendra une liste de positions par lesquelles le chemin devra passer et qui retournera un tel chemin. Comme on suppose le tracé global simple, on segmente le chemin en traçant la route entre 2 positions à chaque fois.  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chemin_complexe</span><span class="p">(</span><span class="o">*</span><span class="n">positions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permet de créer un chemin complexe, c&#39;est à dire</span>
<span class="sd">    un chemin qui passe par n positions</span>
<span class="sd">    Retourne le chemin passant par les positions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cprime</span> <span class="o">=</span> <span class="n">chemin</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="p">[</span><span class="n">cprime</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">c</span>
</pre></div>


<p><em>A noter qu'écrire <code>*positions</code> permet de donner autant d'argument à la fonction qu'on le souhaite</em></p>
<p>Par exemple écrire le code ci-dessous :</p>
<div class="highlight"><pre><span></span><span class="n">route</span> <span class="o">=</span> <span class="n">chemin_complexe</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span>
                        <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>


<p>Correspondra à la grille suivante : </p>
<p><img alt="Chemin sur route" class="center" height="200px" src="https://nightlyside.github.io/new/blog/images/TIPE/chemin_sur_route.jpg" /></p>
<h2>Faire avancer les voitures</h2>
<p>Maintenant qu'on a la grille ainsi que la route qui la parcourt, il est temps de faire avancer les voiture. Pour cela on réutilise le même principe que celui vu dans le post précédent. Cependant un problème nous fait face, en effet comment savoir quelle sera la prochaine case que l'algorithme devra explorer ?</p>
<h3>Recherche des voisins possibles</h3>
<p>Une solution est de chercher toutes les cases qui juxtapose une position donnée (i.e. qui sont juste à côté de la case), on teste chacune des cases pour savoir si il s'agit bien d'une route. Si oui on l'ajoute à la liste des voisins possible, sinon on passe à la suivante. Une fois qu'on a testé toutes les cases on retourne la liste des cases possibles.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cherche_voisins</span><span class="p">(</span><span class="n">chemin</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permet de renvoyer les voisins possibles juxtaposant </span>
<span class="sd">    la position actuelle</span>
<span class="sd">    Retourne une liste de positions </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">voisins</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chemin</span><span class="p">:</span>
            <span class="n">voisins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chemin</span><span class="p">:</span>
            <span class="n">voisins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">voisins</span>
</pre></div>


<p>Pour choisir la case suivante on liste celle possible, on cherche la case la plus proche de celle à atteindre. Dans le cas où on a une déviation, l'algorithme choisira le chemin le plus court "à vol d'oiseau". Ce qui à l'air au premier abord de ressembler à la réalité. Enfin.. c'est logique quoi :)</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">voisin_plus_proche</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">voisins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retourne le voisin le plus proche d&#39;une position donnée</span>
<span class="sd">    Cela permet de décider dans quelle direction aller pour </span>
<span class="sd">    atteindre un point donné</span>
<span class="sd">    Retourne une position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">voisins</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">dmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="n">vproche</span> <span class="o">=</span> <span class="n">voisins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">voisin</span> <span class="ow">in</span> <span class="n">voisins</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">voisin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">voisin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">vproche</span> <span class="o">=</span> <span class="n">voisin</span>
    <span class="k">return</span> <span class="n">vproche</span>
</pre></div>


<h3>Nouveau calcul de la distance</h3>
<p>L'algorithme du post précédent avait besoin de connaitre la distance de la voiture à celle qui lui précédait pour la phase de décélération. Maintenant on ne peux plus juste calculer la distance cartésienne entre les deux points à cause de la forme de la route. Pour la calculer il suffit de partir de la position de la voiture et de remonter le chemin jusqu'à rencontrer la voiture suivante.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">chemin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Essayer de calculer la distance entre 2 cases d&#39;une grille</span>
<span class="sd">    en suivant un chemin donné</span>
<span class="sd">    Retourne un entier correspondant à la longueur du chemin à faire </span>
<span class="sd">    entre le point pos1 et pos2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># On vérifie que les positions appartiennent au chemin</span>
    <span class="k">assert</span> <span class="n">pos1</span> <span class="ow">in</span> <span class="n">route</span> <span class="ow">and</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="n">chemin</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">pos2</span><span class="p">:</span>
        <span class="n">voisins</span> <span class="o">=</span> <span class="n">cherche_voisins</span><span class="p">(</span><span class="n">chemin</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">voisin_plus_proche</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">voisins</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>


<h3>Déplacer la voiture</h3>
<p>Maintenant qu'on a calculé tout ce qu'il fallait, il ne reste plus qu'à déplacer la voiture le long du chemin à l'aide de tout ce qu'on a définit plus haut. Pour cela on part de la position initiale ($pos_i$) puis on parcourt le chemin d'un nombre de cases égal à la vitesse de la voiture ($vitesse$) si il y avait déjà une voiture, par sécurité on s'arrête, sinon on continue jusqu'à ce qu'on ait terminé.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">avance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pos_i</span><span class="p">,</span> <span class="n">vitesse</span><span class="p">,</span> <span class="n">chemin</span><span class="p">,</span> <span class="n">grille</span><span class="p">):</span>     
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calcule la prochaine position d&#39;une voiture sur un chemin</span>
<span class="sd">    en fonction de sa vitesse et de la voiture précédente</span>
<span class="sd">    Si la voiture devant est à l&#39;arret la voiture actuelle</span>
<span class="sd">    s&#39;arrêtera juste avant </span>
<span class="sd">    Retourne une position ainsi que le nombre de case parcourues</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos_i</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">vitesse</span><span class="p">:</span>
        <span class="n">nouvelle_pos</span> <span class="o">=</span> <span class="n">voisin_suivant</span><span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nouvelle_pos</span>
        <span class="k">if</span> <span class="n">grille</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>            
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nouvelle_pos</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>


<h2>Résultat</h2>
<p>On réaplique le même procédé que pour la situation linéaire. On prends sur la route du dessus 100 voitures roulant à 130km/h maximum et on calcule la simulation sur 250 itérations. On calcule chaque itération puis on exporte la grille à chaque instant. En assemblant les images dans un GIF animé, on obtient l'animation suivante :</p>
<p><img alt="Animation 2D" class="center" height="400px" src="https://nightlyside.github.io/new/blog/images/TIPE/sim_2D_anim.gif" /></p>


<!-- Footer -->
<hr>
<div class="container">
    <div class="row justify-content-sm-center">
        <p>© 2020 Alexandre Froehlich</p>
    </div>
</div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>