<!DOCTYPE html>
<html lang="fr">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

    <!-- Favicon -->
    <link rel="icon" href="https://nightlyside.github.io/new/blog/theme/favicon.ico" />
    <link rel="icon" type="image/png" href="https://nightlyside.github.io/new/blog/theme/favicon.png" />

    <!-- Browser Color -->
     <meta name="author" content="Alexandre Froehlich" />
    <meta name="description" content="Site web portfolio de Alexandre Froehlich" />

    <title>[TIPE] Un problème de route - Passage en 2D (3/4) | Alexandre Froehlich
 | Alexandre Froehlich</title>

    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/fontawesome.css" />
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/pygments/default.css">
    <link rel="stylesheet" type="text/css" href="https://nightlyside.github.io/new/blog/theme/css/blog.css" />

    <!-- Javascript -->
    <script src="https://nightlyside.github.io/new/blog/theme/js/jquery.js"></script>
    <script src="https://nightlyside.github.io/new/blog/theme/js/bootstrap.js"></script>
    <script src="https://nightlyside.github.io/new/blog/theme/js/fontawesome.js"></script>
    <script src="https://nightlyside.github.io/new/blog/theme/js/zooming.min.js"></script>
    
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <!--
  _   _ _       _     _   _           _     _      
 | \ | (_) __ _| |__ | |_| |_   _ ___(_) __| | ___ 
 |  \| | |/ _` | '_ \| __| | | | / __| |/ _` |/ _ \
 | |\  | | (_| | | | | |_| | |_| \__ \ | (_| |  __/
 |_| \_|_|\__, |_| |_|\__|_|\__, |___/_|\__,_|\___|
          |___/             |___/                  
-->
    <div class="container-fluid">
        <div class="row">
            <!-- Fixed nav section -->
            <div class="about col-sm-12 col-md-3 col-lg-2">
                <nav class="navbar navbar-fixed-side sticky-top row">
                    <img src="https://nightlyside.github.io/new/blog/images/avatar.png" alt="Alexandre Froehlich" />
                    <h2 class="col-sm-12"><a href="https://nightlyside.github.io/new/blog">Alexandre Froehlich</a></h2>
                    <p class="col-sm-12">
                        Hobbyist programmer. Petit développeur indépendant (aka.
                        Nightlyside) dont le rêve est d’être capable de publier un projet
                        terminé. Actuellement étudiant à l'ENSTA Bretagne
                    </p>

                    <!-- Navigation -->
                    <ul class="nav-list">
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog">Accueil</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/files/cv.pdf">CV</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/categories">Catégories</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog/archives">Archives</a>
                        </li>
                        <li class="nav-item">
                            <span class="nav-item-separator">//</span><a href="https://nightlyside.github.io/new/blog">À propos</a>
                        </li>
                    </ul>

                    <!-- Social links -->
                    <ul class="social">
                        <a href="https://github.com/nightlyside">
                            <li><i class="fab fa-github-square"></i></li>
                        </a>
                        <a href="https://www.linkedin.com/in/alexandre-f-1102298a">
                            <li><i class="fab fa-linkedin"></i></li>
                        </a>
                        <a href="https://twitter.com/froalexandre">
                            <li><i class="fab fa-twitter-square"></i></li>
                        </a>
                        <a href="https://reddit.com/u/nightlyside">
                            <li><i class="fab fa-reddit-square"></i></li>
                        </a>
                    </ul>
                </nav>
            </div>
            <!-- Main content -->
            <div class="col-sm-12 col-md-9 col-lg-10 main">
    <img class="featured_image" src="/images/TIPE/random_front.jpg" alt="Image de l'article">
                 <div class="container content">
                    <!-- Insert content here -->
<h1 class="title">[TIPE] Un problème de route - Passage en 2D (3/4)</h1>
<p class="sous-titre">
    <span class="date-poste">Posté le sam. 02 décembre 2017 dans <a href="category/python.html">python</a></span> <br>
    <span class="temps-lecture">Temps de lecture : 3 minutes</span>
</p>
<hr>
<p>La deuxi&egrave;me &eacute;tape consiste &agrave; passer la simulation &agrave; deux dimensions en vue d'impl&eacute;menter les d&eacute;viations et intersections. On peut encore s&eacute;parer cette &eacute;tape en plusieurs sous-&eacute;tapes : cr&eacute;ation d'une grille qui va accueillir la route, &agrave; la mani&egrave;re d'un plateau contenant des cartes ou des jetons, puis cr&eacute;ation de la route et finalement adaptation des v&eacute;hicules au nouveau syst&egrave;me de route en 2 dimensions.</p>
<h2 id="creation de la grille">Cr&eacute;ation de la grille</h2>
<p>A quoi devra ressembler la grille ? Pour r&eacute;pondre &agrave; cette question on pose les conditions de d&eacute;roulement de la simulation : </p>
<ul>
<li>la grille devra contenir <strong>W</strong> cases en largeur et <strong>H</strong> cases en hauteur </li>
<li>la simulation comportera <strong>T</strong> it&eacute;rations</li>
</ul>
<p>Alors la grille sera repr&eacute;sent&eacute;e par un tableau &agrave; 3 dimensions de taille $T\times H\times W$ alors $\text{grille}[t]$ retournera l'&eacute;tat de la grille &agrave; l'instant $t$.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">grille_random</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Cr&eacute;e une grille de fa&ccedil;on analogue &agrave; grille(w, h, t)</span>
<span class="sd">    Et pr&eacute;remplie la grille avec des valeurs al&eacute;atoires</span>
<span class="sd">    Retourne un tableau de dimension 3 (x, y, t)</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="p">[[[</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
</pre></div>
<p>Avec le syst&egrave;me actuel d'exportation de tableau qui consiste &agrave; attribuer une couleur par case (0 pour blanc, 1 pour vert et 2 pour orange pale) avec chaque couleur associ&eacute;e &agrave; un &eacute;l&eacute;ment de la simulation (respectivement vide, route et v&eacute;hicule). Le code ci-dessus retournera une grille de la bonne taille. Le remplissage &eacute;tant al&eacute;atoire pour mettre en &eacute;vidence la structure de la grille, un exemple est le suivant :</p>
<p><img alt="Grille al&eacute;atoire" class="center img-zoomable" height="200px" src="https://nightlyside.github.io/new/blog/images/TIPE/random.jpg"/></p>
<h2 id="creation de la route">Cr&eacute;ation de la route</h2>
<p>On entame d&egrave;s &agrave; pr&eacute;sent une des parties des plus compliqu&eacute;es avec la cr&eacute;ation de la route. On d&eacute;finit la route comme &eacute;tant l'ensemble des positions prises par un chemin pour aller d'un point <em>A</em> &agrave; un point <em>B</em>.</p>
<p><img alt="AtoB" class="center img-zoomable" height="200px" src="https://nightlyside.github.io/new/blog/images/TIPE/AtoB.jpg"/></p>
<p>En prenant les coordonn&eacute;es de $A = (0,0)$ et $B = (2,2)$ alors le chemin correpondant sera :</p>
<div class="highlight"><pre><span></span><span class="n">chemin</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
</pre></div>
<h3 id="algorithme">Algorithme</h3>
<p>Pour cr&eacute;er la route on initialise un tableau contenant les positions de chaque case. On commence par la case du d&eacute;but puis on choisis la prochaine de fa&ccedil;on relativement simple, on sera probablement amen&eacute; qu'&agrave; cr&eacute;er des droites ou des angles droits, il n'est donc pas n&eacute;cessaire de se compliquer la t&acirc;che. Une fois qu'on est arriv&eacute;e &agrave; la derni&egrave;re case on retourne la liste cr&eacute;e.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chemin</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">):</span>
  <span class="sd">"""</span>
<span class="sd">  Permet de cr&eacute;er un chemin entre deux coordonn&eacute;es pos1, et pos2</span>
<span class="sd">  Prends en argument 2 positions (x, y)</span>
<span class="sd">  Retourne une liste de positions correspondant au chemin cr&eacute;e</span>
<span class="sd">  """</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pos1</span>
  <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pos2</span>
  <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos1</span><span class="p">]</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="n">pos1</span>
  <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">pos2</span><span class="p">:</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">y2</span><span class="p">:</span>
              <span class="n">y</span> <span class="o">-=</span> <span class="mi">1</span>
          <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y2</span><span class="p">:</span>
              <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">c</span>
</pre></div>
<p>A partir de cet algorithme on peut maintenant cr&eacute;er une nouvelle fonction qui prendra une liste de positions par lesquelles le chemin devra passer et qui retournera un tel chemin. Comme on suppose le trac&eacute; global simple, on segmente le chemin en tra&ccedil;ant la route entre 2 positions &agrave; chaque fois. </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chemin_complexe</span><span class="p">(</span><span class="o">*</span><span class="n">positions</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Permet de cr&eacute;er un chemin complexe, c'est &agrave; dire</span>
<span class="sd">    un chemin qui passe par n positions</span>
<span class="sd">    Retourne le chemin passant par les positions</span>
<span class="sd">    """</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cprime</span> <span class="o">=</span> <span class="n">chemin</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">positions</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="p">[</span><span class="n">cprime</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">c</span>
</pre></div>
<blockquote>
<p>A noter qu'&eacute;crire <code>*positions</code> permet de donner autant d'argument &agrave; la fonction qu'on le souhaite</p>
</blockquote>
<p>Par exemple &eacute;crire le code ci-dessous :</p>
<div class="highlight"><pre><span></span><span class="n">route</span> <span class="o">=</span> <span class="n">chemin_complexe</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> 
                        <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span>
                        <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">48</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
<p>Correspondra &agrave; la grille suivante : 
<img alt="chemin_sur_route" class="center img-zoomable" height="200px" src="https://nightlyside.github.io/new/blog/images/TIPE/chemin_sur_route.jpg"/></p>
<h2 id="faire avancer les voitures_1">Faire avancer les voitures</h2>
<p>Maintenant qu'on a la grille ainsi que la route qui la parcourt, il est temps de faire avancer les voiture. Pour cela on r&eacute;utilise le m&ecirc;me principe que celui vu dans le post pr&eacute;c&eacute;dent. Cependant un probl&egrave;me nous fait face, en effet comment savoir quelle sera la prochaine case que l'algorithme devra explorer ?</p>
<h3 id="recherche des voisins possibles">Recherche des voisins possibles</h3>
<p>Une solution est de chercher toutes les cases qui juxtapose une position donn&eacute;e (i.e. qui sont juste &agrave; c&ocirc;t&eacute; de la case), on teste chacune des cases pour savoir si il s'agit bien d'une route. Si oui on l'ajoute &agrave; la liste des voisins possible, sinon on passe &agrave; la suivante. Une fois qu'on a test&eacute; toutes les cases on retourne la liste des cases possibles.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cherche_voisins</span><span class="p">(</span><span class="n">chemin</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Permet de renvoyer les voisins possibles juxtaposant </span>
<span class="sd">    la position actuelle</span>
<span class="sd">    Retourne une liste de positions </span>
<span class="sd">    """</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">voisins</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chemin</span><span class="p">:</span>
            <span class="n">voisins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chemin</span><span class="p">:</span>
            <span class="n">voisins</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">voisins</span>
</pre></div>
<p>Pour choisir la case suivante on liste celle possible, on cherche la case la plus proche de celle &agrave; atteindre. Dans le cas o&ugrave; on a une d&eacute;viation, l'algorithme choisira le chemin le plus court "&agrave; vol d'oiseau". Ce qui &agrave; l'air au premier abord de ressembler &agrave; la r&eacute;alit&eacute;. Enfin.. c'est logique quoi :)</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">voisin_plus_proche</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">voisins</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Retourne le voisin le plus proche d'une position donn&eacute;e</span>
<span class="sd">    Cela permet de d&eacute;cider dans quelle direction aller pour </span>
<span class="sd">    atteindre un point donn&eacute;</span>
<span class="sd">    Retourne une position</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">voisins</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">dmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">"inf"</span><span class="p">)</span>
    <span class="n">vproche</span> <span class="o">=</span> <span class="n">voisins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">voisin</span> <span class="ow">in</span> <span class="n">voisins</span><span class="p">:</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">voisin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">voisin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">vproche</span> <span class="o">=</span> <span class="n">voisin</span>
    <span class="k">return</span> <span class="n">vproche</span>
</pre></div>
<h3 id="nouveau calcul de la distance">Nouveau calcul de la distance</h3>
<p>L'algorithme du post pr&eacute;c&eacute;dent avait besoin de connaitre la distance de la voiture &agrave; celle qui lui pr&eacute;c&eacute;dait pour la phase de d&eacute;c&eacute;l&eacute;ration. Maintenant on ne peux plus juste calculer la distance cart&eacute;sienne entre les deux points &agrave; cause de la forme de la route. Pour la calculer il suffit de partir de la position de la voiture et de remonter le chemin jusqu'&agrave; rencontrer la voiture suivante.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">chemin</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Essayer de calculer la distance entre 2 cases d'une grille</span>
<span class="sd">    en suivant un chemin donn&eacute;</span>
<span class="sd">    Retourne un entier correspondant &agrave; la longueur du chemin &agrave; faire </span>
<span class="sd">    entre le point pos1 et pos2</span>
<span class="sd">    """</span>
    <span class="c1"># On v&eacute;rifie que les positions appartiennent au chemin</span>
    <span class="k">assert</span> <span class="n">pos1</span> <span class="ow">in</span> <span class="n">route</span> <span class="ow">and</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="n">chemin</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">pos1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">pos2</span><span class="p">:</span>
        <span class="n">voisins</span> <span class="o">=</span> <span class="n">cherche_voisins</span><span class="p">(</span><span class="n">chemin</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">voisin_plus_proche</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">voisins</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>
<h3 id="deplacer la voiture">D&eacute;placer la voiture</h3>
<p>Maintenant qu'on a calcul&eacute; tout ce qu'il fallait, il ne reste plus qu'&agrave; d&eacute;placer la voiture le long du chemin &agrave; l'aide de tout ce qu'on a d&eacute;finit plus haut. Pour cela on part de la position initiale (<em>pos</em>) puis on parcourt le chemin d'un nombre de cases &eacute;gal &agrave; la vitesse de la voiture (<em>vitesse</em>) si il y avait d&eacute;j&agrave; une voiture, par s&eacute;curit&eacute; on s'arr&ecirc;te, sinon on continue jusqu'&agrave; ce qu'on ait termin&eacute;.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">avance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pos_i</span><span class="p">,</span> <span class="n">vitesse</span><span class="p">,</span> <span class="n">chemin</span><span class="p">,</span> <span class="n">grille</span><span class="p">):</span>     
    <span class="sd">"""</span>
<span class="sd">    Calcule la prochaine position d'une voiture sur un chemin</span>
<span class="sd">    en fonction de sa vitesse et de la voiture pr&eacute;c&eacute;dente</span>
<span class="sd">    Si la voiture devant est &agrave; l'arret la voiture actuelle</span>
<span class="sd">    s'arr&ecirc;tera juste avant </span>
<span class="sd">    Retourne une position ainsi que le nombre de case parcourues</span>
<span class="sd">    """</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos_i</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">vitesse</span><span class="p">:</span>
        <span class="n">nouvelle_pos</span> <span class="o">=</span> <span class="n">voisin_suivant</span><span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nouvelle_pos</span>
        <span class="k">if</span> <span class="n">grille</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>            
        <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nouvelle_pos</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
<h2 id="resultat_1">R&eacute;sultat</h2>
<p>On r&eacute;aplique le m&ecirc;me proc&eacute;d&eacute; que pour la situation lin&eacute;aire. On prends sur la route du dessus 100 voitures roulant &agrave; 130km/h maximum et on calcule la simulation sur 250 it&eacute;rations. On calcule chaque it&eacute;ration puis on exporte la grille &agrave; chaque instant. En assemblant les images dans un GIF anim&eacute;, on obtient l'animation suivante :</p>
<p><img alt="sim_2D_anim" class="center img-zoomable" height="400px" src="https://nightlyside.github.io/new/blog/images/TIPE/sim_2D_anim.gif"/></p>

                    <!-- Footer -->
                    <hr>
                    <div class="container">
                        <div class="row justify-content-sm-center">
                            <p>© 2020 Alexandre Froehlich</p>
                        </div>
                    </div>
                 </div>
            </div>
        </div>
    </div>
    <script>
      // Listen to images after DOM content is fully loaded
      document.addEventListener('DOMContentLoaded', function () {
        new Zooming({
          // options...
        }).listen('.img-zoomable')
      })
    </script>
</body>

</html>