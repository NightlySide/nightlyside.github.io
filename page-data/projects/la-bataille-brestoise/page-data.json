{"componentChunkName":"component---src-templates-project-tsx","path":"/projects/la-bataille-brestoise","result":{"data":{"site":{"siteMetadata":{"title":"Alexandre Froehlich"}},"markdownRemark":{"id":"b42799cb-6c3e-5cbf-b43d-aaf8d6b08d5c","excerpt":"Dans le cadre de mes études d’ingénieur à l’ENSTA Bretagne, j’ai réalisé à l’aide de mon binôme un projet de fin de cycle en python avec pour objectif d’y intégrer de la programmation orientée objet ainsi que de l’interface homme machine.\n“La bataille brestoise” est le projet que nous avons codé sur près de 3 mois. Il s’agit d’un jeu en réseau de bataille navale en temps réel basé sur la rade de Brest ainsi que sur les bâtiments de la Marine Nationale. Le projet est disponible sur mon repo (installation et utilisation) : https://github.com/NightlySide/La-Bataille-Brestoise Introduction L’objectif initial du projet était de mettre à profit le cours vu sur la programmation orientée objet ainsi que les bases de l’Interface Homme-Machine (IHM). Cependant, avec mon binôme nous avons souhaité pousser le projet plus loin en y intégrant par exemple une connexion clients-serveur et des machines à état finis pour faire de l’intelligence artificielle. Nous avons donc décidé de partir sur le développement d’un jeu de bataille navale en temps réel, inspiré de jeux en .io tel que le célèbre agar.io, dont les bâtiments sont inspirés de la Marine Nationale.\nDans ce jeu, le but sera d’atteindre le niveau 5 en éliminant les adversaires (IA et joueurs réels) pour obtenir des points d’expérience. Si le joueur décède, il réapparaît avec un bâtiment de niveau inférieur.\nDes commandes sont disponibles pour le client et pour le serveur de manière à pouvoir intéragir avec le jeu. De plus une chatbox est mise à disposition des joueurs pour la communication entre les joueurs et la communication des informations sur la partie. L’équilibrage du jeu est obtenu par deux étapes, la première étant un calcul bète et méchant de dégâts par seconde. Les résultats condensés dans un tableau excel permettent de mettre en avant cet équilibrage. La deuxième étape consiste à tester les réglages en jeu. Equilibrage des bâtiments Pour ce jeu, on a tout d’abord commencé par la création du serveur. Le serveur Nous souhaitions implémente une structure de serveur autoritaire et de clients simples (Explication). Tout en ayant une interface simple et déployable sur un serveur externe en headless. Écran de démarrage serveur Pour se faire, en utilisant python le choix évident était de se tourner vers la bibliothèque  pour créer un tunnel TCP entre le client et le serveur.\nCependant son utilisation entraîne un problème. Le tunnel ainsi crée ne fonctionne qu’entre le serveur et un seul client. Or nous…","tableOfContents":"<ul>\n<li><a href=\"/la-bataille-brestoise/#introduction\">Introduction</a></li>\n<li>\n<p><a href=\"/la-bataille-brestoise/#le-serveur\">Le serveur</a></p>\n<ul>\n<li><a href=\"/la-bataille-brestoise/#les-entit%C3%A9s\">Les entités</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/la-bataille-brestoise/#le-client\">Le client</a></p>\n<ul>\n<li><a href=\"/la-bataille-brestoise/#le-radar\">Le radar</a></li>\n<li><a href=\"/la-bataille-brestoise/#la-documentation\">La documentation</a></li>\n</ul>\n</li>\n</ul>","timeToRead":4,"html":"<p>Dans le cadre de mes études d’ingénieur à l’<a href=\"https://www.ensta-bretagne.fr\">ENSTA Bretagne</a>, j’ai réalisé à l’aide de mon binôme un projet de fin de cycle en python avec pour objectif d’y intégrer de la programmation orientée objet ainsi que de l’interface homme machine.\n“La bataille brestoise” est le projet que nous avons codé sur près de 3 mois. Il s’agit d’un jeu en réseau de bataille navale en temps réel basé sur la rade de Brest ainsi que sur les bâtiments de la Marine Nationale.</p>\n<blockquote>\n<p>Le projet est disponible sur mon repo (installation et utilisation) : <a href=\"https://github.com/NightlySide/La-Bataille-Brestoise\">https://github.com/NightlySide/La-Bataille-Brestoise</a></p>\n</blockquote>\n<h2 id=\"introduction\" style=\"position:relative;\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h2>\n<p>L’objectif initial du projet était de mettre à profit le cours vu sur la programmation orientée objet ainsi que les bases de l’Interface Homme-Machine (IHM). Cependant, avec mon binôme nous avons souhaité pousser le projet plus loin en y intégrant par exemple une connexion clients-serveur et des machines à état finis pour faire de l’intelligence artificielle.</p>\n<p>Nous avons donc décidé de partir sur le développement d’un jeu de bataille navale en temps réel, inspiré de jeux en .io tel que le célèbre <a href=\"https://agar.io\">agar.io</a>, dont les bâtiments sont inspirés de la Marine Nationale.\nDans ce jeu, le but sera d’atteindre le niveau 5 en éliminant les adversaires (IA et joueurs réels) pour obtenir des points d’expérience. Si le joueur décède, il réapparaît avec un bâtiment de niveau inférieur.\nDes commandes sont disponibles pour le client et pour le serveur de manière à pouvoir intéragir avec le jeu. De plus une chatbox est mise à disposition des joueurs pour la communication entre les joueurs et la communication des informations sur la partie.</p>\n<p>L’équilibrage du jeu est obtenu par deux étapes, la première étant un calcul bète et méchant de dégâts par seconde. Les résultats condensés dans un tableau excel permettent de mettre en avant cet équilibrage. La deuxième étape consiste à tester les réglages en jeu.</p>\n<p><img src=\"../assets/projets/bataille-brestoise/balance.png\" alt=\"Equilibrage des bâtiments\"></p>\n<p>Pour ce jeu, on a tout d’abord commencé par la création du serveur.</p>\n<h2 id=\"le-serveur\" style=\"position:relative;\"><a href=\"#le-serveur\" aria-label=\"le serveur permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le serveur</h2>\n<p>Nous souhaitions implémente une structure de serveur autoritaire et de clients simples (<a href=\"https://www.gabrielgambetta.com/client-server-game-architecture.html\">Explication</a>). Tout en ayant une interface simple et déployable sur un serveur externe en headless.</p>\n<p><img src=\"../assets/projets/bataille-brestoise/console_serveur.png\" alt=\"Écran de démarrage serveur\"></p>\n<p>Pour se faire, en utilisant python le choix évident était de se tourner vers la bibliothèque <code class=\"language-text\">sockets</code> pour créer un tunnel TCP entre le client et le serveur.\nCependant son utilisation entraîne un problème. Le tunnel ainsi crée ne fonctionne qu’entre le serveur et un seul client. Or nous souhaitons pouvoir jouer en multijoueurs. Deux solutions sont disponibles :</p>\n<ul>\n<li>Utiliser <code class=\"language-text\">sockets</code> avec <code class=\"language-text\">selectors</code> pour faire du multiplexage des entrées et ainsi avoir plusieurs clients connectés en même temps</li>\n<li>Utiliser la nouvelle bibliothèque <code class=\"language-text\">asyncio</code> apportée par python 3</li>\n</ul>\n<p>Nous avons décidé de partir sur la deuxième solution, cette dernière prenant en charge le côté asynchrone du serveur par le biais de deux nouveaux mots clés : <em>async</em> et <em>await</em>.</p>\n<p>A partir de la on peut commencer à créer un serveur prenant en charge la connexion de multiples clients et en leur associant un identifiant unique.</p>\n<h3 id=\"les-entités\" style=\"position:relative;\"><a href=\"#les-entit%C3%A9s\" aria-label=\"les entités permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Les entités</h3>\n<p>Le serveur étant autoritaire c’est à lui de gérer les entités, par conséquent de gérer l’intelligence artificielle de ces dernières. Encore une fois plusieurs méthodes sont disponibles, mais celle qui m’a le plus attiré est la machine à états-finis.\nPour les non initiés, la machine à états finis est un automate qui est dirigé par l’état dans lequel il se trouve actuellement. Ci-dessous, je vous présente le diagramme des états régissant l’intelligence artificielle des entités.</p>\n<p><img src=\"../assets/projets/bataille-brestoise/FSM.png\" alt=\"Diagramme des états des entités\"></p>\n<h2 id=\"le-client\" style=\"position:relative;\"><a href=\"#le-client\" aria-label=\"le client permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le client</h2>\n<p>Pour la création du client plusieurs bibliothèques graphiques sont à notre disposition. Je pourrais citer par exemple tkinter, wxPython, pyQt ou même Kivy. Nous avons décider de développer notre interface avec <a href=\"https://fr.wikipedia.org/wiki/PyQt\">PyQt5</a> en raison de son outil <em>QtDesigner</em> (un outil graphique pour générer des interfaces) et sa documentation très fournie.</p>\n<p>Le premier écran est celui de connexion au serveur. Les serveurs enregistrés sont affichés dans une liste et l’utilisateur peut choisir son pseudonyme.</p>\n<p><img src=\"../assets/projets/bataille-brestoise/start_screen.gif\" alt=\"Écran de connexion client\"></p>\n<p>Une fois connecté, un identifiant unique lui est attribué par le serveur afin de pouvoir se faire authentifier par le serveur ainsi que les autres clients. Cette étape réalisée, l’interface de jeu peut s’ouvrir, présentant l’aire de jeu, la carte (basée sur la rade de Brest), les entités ainsi que la ChatBox et le Radar.</p>\n<p><img src=\"../assets/projets/bataille-brestoise/demo_multi.gif\" alt=\"Ecran de jeu\"></p>\n<h3 id=\"le-radar\" style=\"position:relative;\"><a href=\"#le-radar\" aria-label=\"le radar permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le radar</h3>\n<p>Le radar est l’un des éléments clés du jeu. Il permet de détecter les ennemis aux alentours et de transmettre la position relative au joueur.\nLe fonctionnement est relativement simple : on parcoure les entités présente sur le serveur et on ne garde que celles qui sont à portée par un calcul de distance euclidienne. Ensuite on vérifie que l’entité soit présente sous le faisceau vert (voir image ci-dessous) pour être affichée à l’écran, grâce à du calcul vectoriel.</p>\n<p><img src=\"../assets/projets/bataille-brestoise/radar.gif\" alt=\"Démonstration du Radar\"></p>\n<h3 id=\"la-documentation\" style=\"position:relative;\"><a href=\"#la-documentation\" aria-label=\"la documentation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>La documentation</h3>\n<p>Pour ce projet, la rédaction d’une documentation est nécessaire. Pour nous simplifier la tâche, nous avons décider de tout automatiser en utilisant <a href=\"https://www.sphinx-doc.org\">Sphinx</a>.</p>\n<p>Cet outil nous permet de générer automatiquement la documentation dans le style de Read-the-Docs en prenant la documentation écrite dans les doc-strings du projet. Nous nous sommes tenu au modèle de Google concernant les doc-strings.</p>\n<p><img src=\"../assets/images/projets/bataille-brestoise/docs_rtd.png\" alt=\"Documentation sur ReadTheDocs\"></p>\n<p>Nous avons finalement uploadé la documentation sur ReadTheDocs, elle est disponible à l’adresse : <a href=\"https://la-bataille-brestoise.readthedocs.io/fr/latest/\">https://la-bataille-brestoise.readthedocs.io/fr/latest/</a></p>","frontmatter":{"date":"June 15, 2020","title":"La Bataille Brestoise","slug":null,"tags":["python","IHM","Qt"],"layout":"project","published":true,"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABvElEQVQoz22SWWvbQBSF9UNCS6xlRpKlkbVEy1h23MaJk9gJxJRCA10oTaGvpS/+J4YhbwntLzRkoDf3ykvsJA8fdyTNnDnnIKM+nn5+N76+751N59XJlZKjKXKlJoNCfTzK1KeLoTqdnKuT8UiNzk7VeDxRUnZVVckd6l5/3u8f3hudD9d35a/fUHyZwfnNDEY/ZnD87Q98v6jg59CBS8nBTyPwDkKI8gTyUoIXhOC2g2YSfigaOkkKhhObc1YwcES6yNJYJ3GkRRhoyxd6z/L0G9vV+5at980lb1vm8hlpOUybK1o2WzDmgsG9QIk4g+Qg12leQoYOwk4CHjoIhIAojsFxPbARx/ObNR4GFEH4mv/IA8NvKNhWJFDKWg+OhpAVJdjcBYtxQAeAThoBWq/nk9BamKEge6DLDOb5qi0iEtDkgsSoFxEnTU+0aQ1bOXzmbuVwJVh1a5XLLsaMNYngBBu7oEPk8jXMFy63BGXdmw/eD4H77QU60AS5JXDjpvRd+NbcsKCERpoXd+SQbt7Eo2hNPH8n8nOWFS2xsCruB/jbcPdry3b+YncKN92+gL/yDkERxN1GIf8eAWHLIBAlXn7UAAAAAElFTkSuQmCC","aspectRatio":2.0833333333333335,"src":"/static/92e2ade0d814f05594346da82de35135/ee604/console_serveur.png","srcSet":"/static/92e2ade0d814f05594346da82de35135/69585/console_serveur.png 200w,\n/static/92e2ade0d814f05594346da82de35135/497c6/console_serveur.png 400w,\n/static/92e2ade0d814f05594346da82de35135/ee604/console_serveur.png 800w,\n/static/92e2ade0d814f05594346da82de35135/81e28/console_serveur.png 1002w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"headings":[{"value":"Introduction","depth":2,"id":"introduction"},{"value":"Le serveur","depth":2,"id":"le-serveur"},{"value":"Les entités","depth":3,"id":"les-entités"},{"value":"Le client","depth":2,"id":"le-client"},{"value":"Le radar","depth":3,"id":"le-radar"},{"value":"La documentation","depth":3,"id":"la-documentation"}]}},"pageContext":{"slug":"la-bataille-brestoise","previous":null,"next":{"fields":{"slug":"a-chef-in-the-fridge"},"frontmatter":{"tags":["python","web","SQL"],"title":"A Chef in the fridge","date":"2020-06-21T12:00:00.000Z","slug":null,"layout":"project","published":true}}}},"staticQueryHashes":["3433897746","712016698","781468736"]}